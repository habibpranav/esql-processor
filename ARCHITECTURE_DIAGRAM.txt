╔════════════════════════════════════════════════════════════════════════════════╗
║                    EMF QUERY PROCESSOR - ARCHITECTURE                          ║
╚════════════════════════════════════════════════════════════════════════════════╝

┌─────────────────────────────────────────────────────────────────────────────────┐
│                              USER INPUT                                         │
│                                                                                 │
│  query.esql:                                                                    │
│  ┌───────────────────────────────────────────────────────────────────────────┐ │
│  │ SELECT cust, SUM(X.quant), SUM(Y.quant), SUM(Z.quant)                     │ │
│  │ FROM sales                                                                │ │
│  │ GROUP BY cust: X, Y, Z                                                    │ │
│  │ SUCH THAT X.state = 'NY', Y.state = 'NJ', Z.state = 'CT'                 │ │
│  │ HAVING SUM(X.quant) > 2 * SUM(Y.quant)                                    │ │
│  └───────────────────────────────────────────────────────────────────────────┘ │
└──────────────────────────────────────┬──────────────────────────────────────────┘
                                       │
                                       ▼
┌─────────────────────────────────────────────────────────────────────────────────┐
│                            STEP 1: PARSING                                      │
│                                                                                 │
│  EMFParser.java                                                                 │
│  ┌───────────────────────────────────────────────────────────────────────────┐ │
│  │ • Tokenizes the query                                                     │ │
│  │ • Extracts: SELECT, FROM, WHERE, GROUP BY, SUCH THAT, HAVING              │ │
│  │ • Parses conditions (AND, OR, NOT, comparisons)                           │ │
│  │ • Identifies grouping variables (X, Y, Z)                                 │ │
│  │ • Extracts aggregate functions                                            │ │
│  └───────────────────────────────────────────────────────────────────────────┘ │
└──────────────────────────────────────┬──────────────────────────────────────────┘
                                       │
                                       ▼
┌─────────────────────────────────────────────────────────────────────────────────┐
│                       STEP 2: STRUCTURED QUERY                                  │
│                                                                                 │
│  EMFQuery.java                                                                  │
│  ┌───────────────────────────────────────────────────────────────────────────┐ │
│  │ selectAttributes:     [cust, SUM(X.QUANT), SUM(Y.QUANT), SUM(Z.QUANT)]    │ │
│  │ fromTable:            sales                                               │ │
│  │ groupingAttributes:   [cust]                                              │ │
│  │ groupingVariableNames:[X, Y, Z]                                           │ │
│  │ suchThatMap:                                                              │ │
│  │   X -> "X.CUST = CUST AND X.STATE = 'NY'"                                 │ │
│  │   Y -> "Y.CUST = CUST AND Y.STATE = 'NJ'"                                 │ │
│  │   Z -> "Z.CUST = CUST AND Z.STATE = 'CT'"                                 │ │
│  │ fVectors:             [SUM(X.QUANT), SUM(Y.QUANT), SUM(Z.QUANT)]          │ │
│  │ havingConditions:     "SUM(X.QUANT) > 2 * SUM(Y.QUANT)"                   │ │
│  └───────────────────────────────────────────────────────────────────────────┘ │
└──────────────────────────────────────┬──────────────────────────────────────────┘
                                       │
                                       ▼
┌─────────────────────────────────────────────────────────────────────────────────┐
│                         STEP 3: CODE GENERATION                                 │
│                                                                                 │
│  QueryGenerator.java                                                            │
│  ┌───────────────────────────────────────────────────────────────────────────┐ │
│  │ for (int scanNum = 0; scanNum <= n; scanNum++) {                         │ │
│  │     if (scanNum == 0) {                                                   │ │
│  │         generateScan0(); // Populate mf-structure                         │ │
│  │     } else {                                                              │ │
│  │         String gvName = groupingVariableNames[scanNum-1];                 │ │
│  │         generateScanForGroupingVariable(scanNum, gvName);                 │ │
│  │     }                                                                     │ │
│  │ }                                                                         │ │
│  │ generateHavingAndOutput();                                                │ │
│  └───────────────────────────────────────────────────────────────────────────┘ │
└──────────────────────────────────────┬──────────────────────────────────────────┘
                                       │
                                       ▼
┌─────────────────────────────────────────────────────────────────────────────────┐
│                       STEP 4: GENERATED PROGRAM                                 │
│                                                                                 │
│  GeneratedQuery.java                                                            │
│  ┌───────────────────────────────────────────────────────────────────────────┐ │
│  │ public class GeneratedQuery {                                             │ │
│  │     public static void main(String[] args) {                              │ │
│  │         Connection conn = DriverManager.getConnection(...);               │ │
│  │         Map<String, Map<String, Object>> mfStruct = new HashMap<>();      │ │
│  │                                                                           │ │
│  │         // SCAN 0: Populate mf-structure                                 │ │
│  │         ResultSet rs0 = stmt0.executeQuery("SELECT * FROM sales");       │ │
│  │         while (rs0.next()) {                                             │ │
│  │             String key = rs0.getString("cust");                          │ │
│  │             if (!mfStruct.containsKey(key)) {                            │ │
│  │                 Map<String, Object> row = new HashMap<>();               │ │
│  │                 row.put("cust", key);                                    │ │
│  │                 row.put("SUM_X_QUANT", 0);                               │ │
│  │                 row.put("SUM_Y_QUANT", 0);                               │ │
│  │                 row.put("SUM_Z_QUANT", 0);                               │ │
│  │                 mfStruct.put(key, row);                                  │ │
│  │             }                                                            │ │
│  │         }                                                                │ │
│  │                                                                          │ │
│  │         // SCAN 1: Process X (state = 'NY')                             │ │
│  │         ResultSet rs1 = stmt1.executeQuery("SELECT * FROM sales");      │ │
│  │         while (rs1.next()) {                                            │ │
│  │             if (rs1.getString("state").equals("NY")) {                  │ │
│  │                 String key = rs1.getString("cust");                     │ │
│  │                 Map<String, Object> row = mfStruct.get(key);            │ │
│  │                 row.put("SUM_X_QUANT",                                  │ │
│  │                     (Integer)row.get("SUM_X_QUANT") +                   │ │
│  │                     rs1.getInt("quant"));                               │ │
│  │             }                                                           │ │
│  │         }                                                               │ │
│  │                                                                         │ │
│  │         // SCAN 2: Process Y (state = 'NJ')                            │ │
│  │         // ... similar to SCAN 1 ...                                   │ │
│  │                                                                         │ │
│  │         // SCAN 3: Process Z (state = 'CT')                            │ │
│  │         // ... similar to SCAN 1 ...                                   │ │
│  │                                                                         │ │
│  │         // Apply HAVING and output                                     │ │
│  │         for (Map<String, Object> row : mfStruct.values()) {            │ │
│  │             if ((Integer)row.get("SUM_X_QUANT") >                      │ │
│  │                 2 * (Integer)row.get("SUM_Y_QUANT")) {                 │ │
│  │                 System.out.println(row);                               │ │
│  │             }                                                          │ │
│  │         }                                                              │ │
│  │     }                                                                  │ │
│  │ }                                                                      │ │
│  └────────────────────────────────────────────────────────────────────────┘ │
└──────────────────────────────────────┬─────────────────────────────────────────┘
                                       │
                                       ▼
┌─────────────────────────────────────────────────────────────────────────────────┐
│                          STEP 5: EXECUTION                                      │
│                                                                                 │
│  $ javac GeneratedQuery.java                                                    │
│  $ java GeneratedQuery                                                          │
│                                                                                 │
│  Output:                                                                        │
│  ┌───────────────────────────────────────────────────────────────────────────┐ │
│  │ cust    | SUM_X_QUANT | SUM_Y_QUANT | SUM_Z_QUANT                         │ │
│  │ ────────────────────────────────────────────────────────────────────      │ │
│  │ Alice   | 1500        | 500         | 800                                 │ │
│  │ Bob     | 2000        | 600         | 900                                 │ │
│  └───────────────────────────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────────────────────────────┘

╔════════════════════════════════════════════════════════════════════════════════╗
║                           KEY DATA STRUCTURES                                  ║
╚════════════════════════════════════════════════════════════════════════════════╝

┌─────────────────────────────────────────────────────────────────────────────────┐
│  MF-STRUCTURE (In-Memory) - THE ONLY THING IN RAM!                              │
│                                                                                 │
│  Map<String, Map<String, Object>>                                               │
│  ┌───────────┬───────────────┬───────────────┬───────────────┬───────────────┐ │
│  │    Key    │     cust      │  SUM_X_QUANT  │  SUM_Y_QUANT  │  SUM_Z_QUANT  │ │
│  ├───────────┼───────────────┼───────────────┼───────────────┼───────────────┤ │
│  │ "Alice"   │    "Alice"    │      1500     │      500      │      800      │ │
│  │ "Bob"     │    "Bob"      │      2000     │      600      │      900      │ │
│  │ "Charlie" │    "Charlie"  │      1200     │      300      │      600      │ │
│  └───────────┴───────────────┴───────────────┴───────────────┴───────────────┘ │
│                                                                                 │
│  Size: 3 rows (one per customer)                                                │
│  NOT 1,000,000 rows (from the sales table)!                                     │
└─────────────────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────────────────┐
│  DATABASE TABLE (On Disk) - SCANNED MULTIPLE TIMES                              │
│                                                                                 │
│  Sales Table (1,000,000 rows)                                                   │
│  ┌───────────┬──────────┬─────────┬───────┬──────────┬────────┬───────────────┐ │
│  │   cust    │   prod   │   day   │ month │   year   │ state  │     quant     │ │
│  ├───────────┼──────────┼─────────┼───────┼──────────┼────────┼───────────────┤ │
│  │  Alice    │  Widget  │   15    │   3   │   2023   │   NY   │      100      │ │
│  │  Bob      │  Gadget  │   16    │   3   │   2023   │   NJ   │      200      │ │
│  │  Alice    │  Tool    │   17    │   3   │   2023   │   CT   │      150      │ │
│  │  ...      │  ...     │   ...   │  ...  │   ...    │  ...   │      ...      │ │
│  │  (1M rows)                                                                  │ │
│  └───────────┴──────────┴─────────┴───────┴──────────┴────────┴───────────────┘ │
│                                                                                 │
│  This is NEVER loaded into memory!                                              │
│  We scan it using database cursors (ResultSet)                                  │
└─────────────────────────────────────────────────────────────────────────────────┘

╔════════════════════════════════════════════════════════════════════════════════╗
║                         MEMORY USAGE ANALYSIS                                  ║
╚════════════════════════════════════════════════════════════════════════════════╝

OLD APPROACH (ArrayList - WRONG):
┌─────────────────────────────────────────────────────────────────────────────────┐
│  List<Row> allData = new ArrayList<>();                                        │
│  while (rs.next()) {                                                            │
│      allData.add(new Row(rs)); // Creates 1,000,000 Row objects!               │
│  }                                                                              │
│                                                                                 │
│  Memory: 1,000,000 rows × 200 bytes/row = 200 MB                                │
│  Problem: OutOfMemoryError for large datasets!                                  │
└─────────────────────────────────────────────────────────────────────────────────┘

NEW APPROACH (mf-structure - CORRECT):
┌─────────────────────────────────────────────────────────────────────────────────┐
│  Map<String, Map<String, Object>> mfStruct = new HashMap<>();                  │
│  while (rs.next()) {                                                            │
│      Map<String, Object> row = mfStruct.get(key);                              │
│      // Update aggregates (NO new objects created)                             │
│  }                                                                              │
│                                                                                 │
│  Memory: 100 groups × 100 bytes/group = 10 KB                                   │
│  Improvement: 20,000× less memory!                                              │
└─────────────────────────────────────────────────────────────────────────────────┘

╔════════════════════════════════════════════════════════════════════════════════╗
║                            SUCCESS CHECKLIST                                   ║
╚════════════════════════════════════════════════════════════════════════════════╝

 1. NO ArrayList of entire table
 2. ONLY mf-structure in memory
 3. Database cursor scans (not loading everything)
 4. Dynamic code generation (adapts to any query)
 5. Follows algorithm from papers (n+1 scans)
 6. Scalable architecture
 7. Clean separation of concerns
 8. Well-documented code

